# Billogram Test Task

## General description

The task was to design an implement a system for generating and fetching discount codes. Specifically, I have implemented three endpoints:
- An endpoint for brands to generate codes
- An endpoint for customers to see which discounts are available
- An endpoint for customers to fetch an individual discount, which will reveal a code and notify the brand, providing information about the user

## Assumptions about the general design of the system

I have assumed that there are separate microservices that handle the following aspects of the system:
- User/Customer data
- Brands
- Authentication and routing
- Discounts (this is the service that has been implemented)

They all handle and own their own data, and communicate via http api:s, which I've abstracted away and represented via `Client` classes for the user and brand services respectively.

## Usage

I have assumed that there are two separate web applications, one for brand administrators, and one for customers. These make http calls to a service that handles authentication (via OATH perhaps), and then routes calls to underlying services. In my implementation I have assumed that this has already happened, and that calls can be considered properly authenticated.

The following endpoints can be called:

```json
REGISTER DISCOUNT

Called from the brand web app for a brand to generate a code. They supply the discount percentage, and a title and 
description that can be presented to potential consumers, and gets a response where a generated code has been added

http://localhost:8080/discounts/brands/{brandId} (POST)
Request body (json):
{
    "title": String,
    "description": String,
    "discountPercent": Int (must be between 1 and 100 inclusive)
}
Response:
{
    "title": String,
    "description": String,
    "discountPercent": Int,
    "code": String (as a UUID, generated by the system)
}
```

```json
GET AVAILABLE DISCOUNTS

Called from the user facing web app, provides all possible discounts that the user can sign up for.

http://localhost:8080/discounts (GET)
Response:
{
    "discounts": [
      {
          "id": Long,
          "title": String,
          "description": String,
          "discountPercentage": Int
      }    
    ]
}
```

```json
FETCH DISCOUNT

Called from the user facing web app, registers a user to receive a code.

http://localhost:8080/discounts/{discountId}?userId={userId} (POST)
{
  "code": String
}
```

Fetching a discount will notify the brand with the user data. How this is done is not implemented, and assumed to be handled by the Brand microservice, which is being notified via the mocked client. Presumably this can be done in a multitude of ways, for instance by having the brand register a url for webhooks, a shared event queue, ftp:ing files, or whatever is convenient.

## How to build and run

I've implemented the api in kotlin, with a small spring boot app. It requires java 11 or higher, and maven to be installed in order to run. Note that it may not work on java 16 due to some incompatibilities with the kotlin compiler.

In order to compile and run it, run the following command from the folder containing `pom.xml`:
```shell
mvn spring-boot:run
```

## Other notes

- The application is currently using an in-memory sql database, wrapped with Spring Data and JPA. With more time, I would probably have opted for a relational db, like Postgres, simply because I am more familiar with it than other types of databases (like document dbs, etc)
- In a proper setting, I would have implemented both unit tests and api-level tests to verify the functionality. Time constraints meant I decided to prioritise the implementation, since I thought I would give you more information about how I structure my code
- I decided to couple notification of the brand on users getting discounts loosely, by letting the CustomerDiscount domain service define an interface whose implementors are called when a discount is fetched, without the customer discount domain having to know who wants to do what with that information.
- Had I had more time, I would have liked to have made a docker image of the application to make it easier to run
